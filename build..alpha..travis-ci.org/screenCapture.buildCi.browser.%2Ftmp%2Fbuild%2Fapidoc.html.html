<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://www.adaltas.com/projects/node-printf">printf (v0.2.5)</a>
</h1>
<h4>Full implementation of the `printf` family in pure JS.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.printf">module printf</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.printf">
            function <span class="apidocSignatureSpan"></span>printf
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter">
            function <span class="apidocSignatureSpan">printf.</span>Formatter
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">printf.</span>Formatter.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.printf.Formatter">module printf.Formatter</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.Formatter">
            function <span class="apidocSignatureSpan">printf.</span>Formatter
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.printf.Formatter.prototype">module printf.Formatter.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.prototype._parseDelim">
            function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>_parseDelim
            <span class="apidocSignatureSpan">(mapping, intmapping, flags, minWidth, period, precision, specifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.prototype.fitField">
            function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>fitField
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.prototype.format">
            function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>format
            <span class="apidocSignatureSpan">(filler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.prototype.formatDouble">
            function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>formatDouble
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.prototype.formatInt">
            function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>formatInt
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.prototype.formatObject">
            function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>formatObject
            <span class="apidocSignatureSpan">(token)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.prototype.spacePad">
            function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>spacePad
            <span class="apidocSignatureSpan">(token, length)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.printf.Formatter.prototype.zeroPad">
            function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>zeroPad
            <span class="apidocSignatureSpan">(token, length)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>_re</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>_specifiers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>_spaces10</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>_zeros10</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.printf" id="apidoc.module.printf">module printf</a></h1>


    <h2>
        <a href="#apidoc.element.printf.printf" id="apidoc.element.printf.printf">
        function <span class="apidocSignatureSpan"></span>printf
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">printf = function (){
  var args = Array.prototype.slice.call(arguments),
    stream, format;
  if(args[0] instanceof require('stream').Stream){
    stream = args.shift();
  }
  format = args.shift();
  var formatter = new Formatter(format);
  var string = formatter.format.apply(formatter, args);
  if(stream){
    stream.write(string);
  }else{
    return string;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.printf.Formatter" id="apidoc.element.printf.Formatter">
        function <span class="apidocSignatureSpan">printf.</span>Formatter
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Formatter = function (format){
  this._mapped = false;
  this._format = format;
  this._tokens = tokenize(format, this._re, this._parseDelim, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
it 'vs. Formatter', -&gt;
  i = 0
  while i &lt; 1000
    printf '%d %s Pockets', i, 'Hot'
    i++

it 'Formatter', -&gt;
  str = new printf.<span class="apidocCodeKeywordSpan">Formatter</span>('%d %s Pockets')
  i = 0
  while i &lt; 1000
    str.format i, 'Hot'
    i++

it 'Miscellaneous', -&gt;
  printf('+%s+', 'hello').should.eql '+hello+'
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.printf.Formatter" id="apidoc.module.printf.Formatter">module printf.Formatter</a></h1>


    <h2>
        <a href="#apidoc.element.printf.Formatter.Formatter" id="apidoc.element.printf.Formatter.Formatter">
        function <span class="apidocSignatureSpan">printf.</span>Formatter
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Formatter = function (format){
  this._mapped = false;
  this._format = format;
  this._tokens = tokenize(format, this._re, this._parseDelim, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
it 'vs. Formatter', -&gt;
  i = 0
  while i &lt; 1000
    printf '%d %s Pockets', i, 'Hot'
    i++

it 'Formatter', -&gt;
  str = new printf.<span class="apidocCodeKeywordSpan">Formatter</span>('%d %s Pockets')
  i = 0
  while i &lt; 1000
    str.format i, 'Hot'
    i++

it 'Miscellaneous', -&gt;
  printf('+%s+', 'hello').should.eql '+hello+'
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.printf.Formatter.prototype" id="apidoc.module.printf.Formatter.prototype">module printf.Formatter.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.printf.Formatter.prototype._parseDelim" id="apidoc.element.printf.Formatter.prototype._parseDelim">
        function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>_parseDelim
        <span class="apidocSignatureSpan">(mapping, intmapping, flags, minWidth, period, precision, specifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_parseDelim = function (mapping, intmapping, flags, minWidth, period, precision, specifier){
  if(mapping){
    this._mapped = true;
  }
  return {
    mapping: mapping,
    intmapping: intmapping,
    flags: flags,
    _minWidth: minWidth, // May be dependent on parameters
    period: period,
    _precision: precision, // May be dependent on parameters
    specifier: specifier
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.printf.Formatter.prototype.fitField" id="apidoc.element.printf.Formatter.prototype.fitField">
        function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>fitField
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fitField = function (token) {
  if(token.maxWidth &gt;= 0 &amp;&amp; token.arg.length &gt; token.maxWidth){
    return token.arg.substring(0, token.maxWidth);
  }
  if(token.zeroPad){
    this.zeroPad(token, token.minWidth);
    return;
  }
  this.spacePad(token);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if(token.period != '.'){
          token.precision = 6;
        }
        this.formatDouble(token);
      }else if(token.isObject){
        this.formatObject(token);
      }
      this.<span class="apidocCodeKeywordSpan">fitField</span>(token);

      str += '' + token.arg;
    }
  }

  return str;
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.printf.Formatter.prototype.format" id="apidoc.element.printf.Formatter.prototype.format">
        function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>format
        <span class="apidocSignatureSpan">(filler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">format = function (filler){
  if(this._mapped &amp;&amp; typeof filler != 'object'){
    throw new Error('format requires a mapping');
  }

  var str = '';
  var position = 0;
  for(var i = 0, token; i &lt; this._tokens.length; i++){
    token = this._tokens[i];

    if(typeof token == 'string'){
      str += token;
    }else{
      if(this._mapped){
        // Identify value of property defined in `token.mapping`
        var tokens = token.mapping.split('.');
        var value = filler;
        for (var j = 0, c = tokens.length; j &lt; c; j++) {
          value = value[tokens[j]];
          if (typeof value === 'undefined') {
            break
          }
        }
        if(typeof value == 'undefined'){
          throw new Error('missing key ' + token.mapping);
        }
        token.arg = value;
      }else{
        if(token.intmapping){
          position = parseInt(token.intmapping) - 1;
        }
        if(position &gt;= arguments.length){
          throw new Error('got ' + arguments.length + ' printf arguments, insufficient for \'' + this._format + '\'');
        }
        token.arg = arguments[position++];
      }

      if(!token.compiled){
        token.compiled = true;
        token.sign = '';
        token.zeroPad = false;
        token.rightJustify = false;
        token.alternative = false;

        var flags = {};
        for(var fi = token.flags.length; fi--;){
          var flag = token.flags.charAt(fi);
          flags[flag] = true;
          switch(flag){
            case ' ':
              token.sign = ' ';
              break;
            case '+':
              token.sign = '+';
              break;
            case '0':
              token.zeroPad = (flags['-']) ? false : true;
              break;
            case '-':
              token.rightJustify = true;
              token.zeroPad = false;
              break;
            case '#':
              token.alternative = true;
              break;
            default:
              throw Error('bad formatting flag \'' + token.flags.charAt(fi) + '\'');
          }
        }

        token.minWidth = (token._minWidth) ? parseInt(token._minWidth) : 0;
        token.maxWidth = -1;
        token.toUpper = false;
        token.isUnsigned = false;
        token.isInt = false;
        token.isDouble = false;
        token.isObject = false;
        token.precision = 1;
        if(token.period == '.'){
          if(token._precision){
            token.precision = parseInt(token._precision);
          }else{
            token.precision = 0;
          }
        }

        var mixins = this._specifiers[token.specifier];
        if(typeof mixins == 'undefined'){
          throw new Error('unexpected specifier \'' + token.specifier + '\'');
        }
        if(mixins.extend){
          var s = this._specifiers[mixins.extend];
          for(var k in s){
            mixins[k] = s[k];
          }
          delete mixins.extend;
        }
        for(var l in mixins){
          token[l] = mixins[l];
        }
      }

      if(typeof token.setArg == 'function'){
        token.setArg(token);
      }

      if(typeof token.setMaxWidth == 'function'){
        token.setMaxWidth(token);
      }

      if(token._minWidth == '*'){
        if(this._mapped){
          throw new Error('* width not supported in mapped formats');
        }
        token.minWidth = parseInt(arguments[position++]);
        if(isNaN(token.minWidth)){
          throw new Error('the argument for * width at position ' + position + ' is not a number in ' + this._format);
        }
        // negative width means rightJustify
        if (token.minWidth &lt; 0) {
          token.rightJustify = true;
          token.minWidth = -token.minWidth;
        }
      }

      if(token._precision == '*' &amp;&amp; token.period == '.'){
        if(this._mapped){
          throw new Error('* precision not supported in mapped formats');
        }
        token.precision = parseInt(arguments[position++]);
        if(isNaN(token.precision)){
          throw Error('the argument for * precision at position ' + position + ' is not a number ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.printf.Formatter.prototype.formatDouble" id="apidoc.element.printf.Formatter.prototype.formatDouble">
        function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>formatDouble
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatDouble = function (token) {
  var f = parseFloat(token.arg);
  if(!isFinite(f)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not a float; parseFloat returned ' + f);
    }
    // C99 says that for 'f':
    //   infinity -&gt; '[-]inf' or '[-]infinity' ('[-]INF' or '[-]INFINITY' for 'F')
    //   NaN -&gt; a string  starting with 'nan' ('NAN' for 'F')
    // this is not commonly implemented though.
    //return '' + f;
    f = 0;
  }

  switch(token.doubleNotation) {
    case 'e': {
      token.arg = f.toExponential(token.precision);
      break;
    }
    case 'f': {
      token.arg = f.toFixed(token.precision);
      break;
    }
    case 'g': {
      // C says use 'e' notation if exponent is &lt; -4 or is &gt;= prec
      // ECMAScript for toPrecision says use exponential notation if exponent is &gt;= prec,
      // though step 17 of toPrecision indicates a test for &lt; -6 to force exponential.
      if(Math.abs(f) &lt; 0.0001){
        //print('forcing exponential notation for f=' + f);
        token.arg = f.toExponential(token.precision &gt; 0 ? token.precision - 1 : token.precision);
      }else{
        token.arg = f.toPrecision(token.precision);
      }

      // In C, unlike 'f', 'gG' removes trailing 0s from fractional part, unless alternative format flag ('#').
      // But ECMAScript formats toPrecision as 0.00100000. So remove trailing 0s.
      if(!token.alternative){
        //print('replacing trailing 0 in \'' + s + '\'');
        token.arg = token.arg.replace(/(\..*[^0])0*e/, '$1e');
        // if fractional part is entirely 0, remove it and decimal point
        token.arg = token.arg.replace(/\.0*e/, 'e').replace(/\.0$/,'');
      }
      break;
    }
    default: throw new Error('unexpected double notation \'' + token.doubleNotation + '\'');
  }

  // C says that exponent must have at least two digits.
  // But ECMAScript does not; toExponential results in things like '1.000000e-8' and '1.000000e+8'.
  // Note that s.replace(/e([\+\-])(\d)/, 'e$10$2') won't work because of the '$10' instead of '$1'.
  // And replace(re, func) isn't supported on IE50 or Safari1.
  token.arg = token.arg.replace(/e\+(\d)$/, 'e+0$1').replace(/e\-(\d)$/, 'e-0$1');

  // if alt, ensure a decimal point
  if(token.alternative){
    token.arg = token.arg.replace(/^(\d+)$/,'$1.');
    token.arg = token.arg.replace(/^(\d+)e/,'$1.e');
  }

  if(f &gt;= 0 &amp;&amp; token.sign){
    token.arg = token.sign + token.arg;
  }

  token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      token.zeroPad = false;
    }
    this.formatInt(token);
  }else if(token.isDouble){
    if(token.period != '.'){
      token.precision = 6;
    }
    this.<span class="apidocCodeKeywordSpan">formatDouble</span>(token);
  }else if(token.isObject){
    this.formatObject(token);
  }
  this.fitField(token);

  str += '' + token.arg;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.printf.Formatter.prototype.formatInt" id="apidoc.element.printf.Formatter.prototype.formatInt">
        function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>formatInt
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatInt = function (token) {
  var i = parseInt(token.arg);
  if(!isFinite(i)){ // isNaN(f) || f == Number.POSITIVE_INFINITY || f == Number.NEGATIVE_INFINITY)
    // allow this only if arg is number
    if(typeof token.arg != 'number'){
      throw new Error('format argument \'' + token.arg + '\' not an integer; parseInt returned ' + i);
    }
    //return '' + i;
    i = 0;
  }

  // if not base 10, make negatives be positive
  // otherwise, (-10).toString(16) is '-a' instead of 'fffffff6'
  if(i &lt; 0 &amp;&amp; (token.isUnsigned || token.base != 10)){
    i = 0xffffffff + i + 1;
  }

  if(i &lt; 0){
    token.arg = (- i).toString(token.base);
    this.zeroPad(token);
    token.arg = '-' + token.arg;
  }else{
    token.arg = i.toString(token.base);
    // need to make sure that argument 0 with precision==0 is formatted as ''
    if(!i &amp;&amp; !token.precision){
      token.arg = '';
    }else{
      this.zeroPad(token);
    }
    if(token.sign){
      token.arg = token.sign + token.arg;
    }
  }
  if(token.base == 16){
    if(token.alternative){
      token.arg = '0x' + token.arg;
    }
    token.arg = token.toUpper ? token.arg.toUpperCase() : token.arg.toLowerCase();
  }
  if(token.base == 8){
    if(token.alternative &amp;&amp; token.arg.charAt(0) != '0'){
      token.arg = '0' + token.arg;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}
if(token.isInt){
  // a specified precision means no zero padding
  if(token.period == '.'){
    token.zeroPad = false;
  }
  this.<span class="apidocCodeKeywordSpan">formatInt</span>(token);
}else if(token.isDouble){
  if(token.period != '.'){
    token.precision = 6;
  }
  this.formatDouble(token);
}else if(token.isObject){
  this.formatObject(token);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.printf.Formatter.prototype.formatObject" id="apidoc.element.printf.Formatter.prototype.formatObject">
        function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>formatObject
        <span class="apidocSignatureSpan">(token)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">formatObject = function (token) {
  // If no precision is specified, then reset it to null (infinite depth).
  var precision = (token.period === '.') ? token.precision : null;
  token.arg = util.inspect(token.arg, !token.alternative, precision);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.formatInt(token);
    }else if(token.isDouble){
      if(token.period != '.'){
        token.precision = 6;
      }
      this.formatDouble(token);
    }else if(token.isObject){
      this.<span class="apidocCodeKeywordSpan">formatObject</span>(token);
    }
    this.fitField(token);

    str += '' + token.arg;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.printf.Formatter.prototype.spacePad" id="apidoc.element.printf.Formatter.prototype.spacePad">
        function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>spacePad
        <span class="apidocSignatureSpan">(token, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">spacePad = function (token, length) {
  length = (arguments.length == 2) ? length : token.minWidth;
  if(typeof token.arg != 'string'){
    token.arg = '' + token.arg;
  }
  var tenless = length - 10;
  while(token.arg.length &lt; tenless){
    token.arg = (token.rightJustify) ? token.arg + this._spaces10 : this._spaces10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._spaces10.substring(0, pad) : this._spaces10.substring(0, pad) + token.arg
;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if(token.maxWidth &gt;= 0 &amp;&amp; token.arg.length &gt; token.maxWidth){
  return token.arg.substring(0, token.maxWidth);
}
if(token.zeroPad){
  this.zeroPad(token, token.minWidth);
  return;
}
this.<span class="apidocCodeKeywordSpan">spacePad</span>(token);
};
Formatter.prototype.spacePad = function(token, /*Int*/ length) {
length = (arguments.length == 2) ? length : token.minWidth;
if(typeof token.arg != 'string'){
  token.arg = '' + token.arg;
}
var tenless = length - 10;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.printf.Formatter.prototype.zeroPad" id="apidoc.element.printf.Formatter.prototype.zeroPad">
        function <span class="apidocSignatureSpan">printf.Formatter.prototype.</span>zeroPad
        <span class="apidocSignatureSpan">(token, length)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">zeroPad = function (token, length) {
  length = (arguments.length == 2) ? length : token.precision;
  var negative = false;
  if(typeof token.arg != "string"){
    token.arg = "" + token.arg;
  }
  if (token.arg.substr(0,1) === '-') {
    negative = true;
    token.arg = token.arg.substr(1);
  }

  var tenless = length - 10;
  while(token.arg.length &lt; tenless){
    token.arg = (token.rightJustify) ? token.arg + this._zeros10 : this._zeros10 + token.arg;
  }
  var pad = length - token.arg.length;
  token.arg = (token.rightJustify) ? token.arg + this._zeros10.substring(0, pad) : this._zeros10.substring(0, pad) + token.arg;
  if (negative) token.arg = '-' + token.arg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// otherwise, (-10).toString(16) is '-a' instead of 'fffffff6'
if(i &lt; 0 &amp;&amp; (token.isUnsigned || token.base != 10)){
  i = 0xffffffff + i + 1;
}

if(i &lt; 0){
  token.arg = (- i).toString(token.base);
  this.<span class="apidocCodeKeywordSpan">zeroPad</span>(token);
  token.arg = '-' + token.arg;
}else{
  token.arg = i.toString(token.base);
  // need to make sure that argument 0 with precision==0 is formatted as ''
  if(!i &amp;&amp; !token.precision){
    token.arg = '';
  }else{
...</pre></li>
    </ul>










</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>